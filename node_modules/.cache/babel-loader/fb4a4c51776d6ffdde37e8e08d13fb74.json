{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert } from \"../../core/util/Debug\";\nimport { theWindow } from \"../../core/context/AudioContext\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n/**\n * A wrapper around the MediaRecorder API. Unlike the rest of Tone.js, this module does not offer\n * any sample-accurate scheduling because it is not a feature of the MediaRecorder API.\n * This is only natively supported in Chrome and Firefox.\n * For a cross-browser shim, install (audio-recorder-polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n * @example\n * const recorder = new Tone.Recorder();\n * const synth = new Tone.Synth().connect(recorder);\n * // start recording\n * recorder.start();\n * // generate a few notes\n * synth.triggerAttackRelease(\"C3\", 0.5);\n * synth.triggerAttackRelease(\"C4\", 0.5, \"+1\");\n * synth.triggerAttackRelease(\"C5\", 0.5, \"+2\");\n * // wait for the notes to end and stop the recording\n * setTimeout(async () => {\n * \t// the recorded audio is returned as a blob\n * \tconst recording = await recorder.stop();\n * \t// download the recording by creating an anchor element and blob url\n * \tconst url = URL.createObjectURL(recording);\n * \tconst anchor = document.createElement(\"a\");\n * \tanchor.download = \"recording.webm\";\n * \tanchor.href = url;\n * \tanchor.click();\n * }, 4000);\n * @category Component\n */\n\nexport class Recorder extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(Recorder.getDefaults(), arguments));\n    this.name = \"Recorder\";\n    const options = optionsFromArguments(Recorder.getDefaults(), arguments);\n    this.input = new Gain({\n      context: this.context\n    });\n    assert(Recorder.supported, \"Media Recorder API is not available\");\n    this._stream = this.context.createMediaStreamDestination();\n    this.input.connect(this._stream);\n    this._recorder = new MediaRecorder(this._stream.stream, {\n      mimeType: options.mimeType\n    });\n  }\n\n  static getDefaults() {\n    return ToneAudioNode.getDefaults();\n  }\n  /**\n   * The mime type is the format that the audio is encoded in. For Chrome\n   * that is typically webm encoded as \"vorbis\".\n   */\n\n\n  get mimeType() {\n    return this._recorder.mimeType;\n  }\n  /**\n   * Test if your platform supports the Media Recorder API. If it's not available,\n   * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n   */\n\n\n  static get supported() {\n    return theWindow !== null && Reflect.has(theWindow, \"MediaRecorder\");\n  }\n  /**\n   * Get the playback state of the Recorder, either \"started\", \"stopped\" or \"paused\"\n   */\n\n\n  get state() {\n    if (this._recorder.state === \"inactive\") {\n      return \"stopped\";\n    } else if (this._recorder.state === \"paused\") {\n      return \"paused\";\n    } else {\n      return \"started\";\n    }\n  }\n  /**\n   * Start the Recorder. Returns a promise which resolves\n   * when the recorder has started.\n   */\n\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(this.state !== \"started\", \"Recorder is already started\");\n      const startPromise = new Promise(done => {\n        const handleStart = () => {\n          this._recorder.removeEventListener(\"start\", handleStart, false);\n\n          done();\n        };\n\n        this._recorder.addEventListener(\"start\", handleStart, false);\n      });\n\n      this._recorder.start();\n\n      return yield startPromise;\n    });\n  }\n  /**\n   * Stop the recorder. Returns a promise with the recorded content until this point\n   * encoded as [[mimeType]]\n   */\n\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(this.state !== \"stopped\", \"Recorder is not started\");\n      const dataPromise = new Promise(done => {\n        const handleData = e => {\n          this._recorder.removeEventListener(\"dataavailable\", handleData, false);\n\n          done(e.data);\n        };\n\n        this._recorder.addEventListener(\"dataavailable\", handleData, false);\n      });\n\n      this._recorder.stop();\n\n      return yield dataPromise;\n    });\n  }\n  /**\n   * Pause the recorder\n   */\n\n\n  pause() {\n    assert(this.state === \"started\", \"Recorder must be started\");\n\n    this._recorder.pause();\n\n    return this;\n  }\n\n  dispose() {\n    super.dispose();\n    this.input.dispose();\n\n    this._stream.disconnect();\n\n    return this;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}