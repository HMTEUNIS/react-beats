{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport class UserMedia extends ToneAudioNode {\n  constructor() {\n    super(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n    this.name = \"UserMedia\";\n    const options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    this._volume = this.output = new Volume({\n      context: this.context,\n      volume: options.volume\n    });\n    this.volume = this._volume.volume;\n    readOnly(this, \"volume\");\n    this.mute = options.mute;\n  }\n\n  static getDefaults() {\n    return Object.assign(ToneAudioNode.getDefaults(), {\n      mute: false,\n      volume: 0\n    });\n  }\n  /**\n   * Open the media stream. If a string is passed in, it is assumed\n   * to be the label or id of the stream, if a number is passed in,\n   * it is the input number of the stream.\n   * @param  labelOrId The label or id of the audio input media device.\n   *                   With no argument, the default stream is opened.\n   * @return The promise is resolved when the stream is open.\n   */\n\n\n  open(labelOrId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      assert(UserMedia.supported, \"UserMedia is not supported\"); // close the previous stream\n\n      if (this.state === \"started\") {\n        this.close();\n      }\n\n      const devices = yield UserMedia.enumerateDevices();\n\n      if (isNumber(labelOrId)) {\n        this._device = devices[labelOrId];\n      } else {\n        this._device = devices.find(device => {\n          return device.label === labelOrId || device.deviceId === labelOrId;\n        }); // didn't find a matching device\n\n        if (!this._device && devices.length > 0) {\n          this._device = devices[0];\n        }\n\n        assert(isDefined(this._device), \"No matching device \".concat(labelOrId));\n      } // do getUserMedia\n\n\n      const constraints = {\n        audio: {\n          echoCancellation: false,\n          sampleRate: this.context.sampleRate,\n          noiseSuppression: false,\n          mozNoiseSuppression: false\n        }\n      };\n\n      if (this._device) {\n        // @ts-ignore\n        constraints.audio.deviceId = this._device.deviceId;\n      }\n\n      const stream = yield navigator.mediaDevices.getUserMedia(constraints); // start a new source only if the previous one is closed\n\n      if (!this._stream) {\n        this._stream = stream; // Wrap a MediaStreamSourceNode around the live input stream.\n\n        const mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node\n\n        connect(mediaStreamNode, this.output);\n        this._mediaStream = mediaStreamNode;\n      }\n\n      return this;\n    });\n  }\n  /**\n   * Close the media stream\n   */\n\n\n  close() {\n    if (this._stream && this._mediaStream) {\n      this._stream.getAudioTracks().forEach(track => {\n        track.stop();\n      });\n\n      this._stream = undefined; // remove the old media stream\n\n      this._mediaStream.disconnect();\n\n      this._mediaStream = undefined;\n    }\n\n    this._device = undefined;\n    return this;\n  }\n  /**\n   * Returns a promise which resolves with the list of audio input devices available.\n   * @return The promise that is resolved with the devices\n   * @example\n   * Tone.UserMedia.enumerateDevices().then((devices) => {\n   * \t// print the device labels\n   * \tconsole.log(devices.map(device => device.label));\n   * });\n   */\n\n\n  static enumerateDevices() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const allDevices = yield navigator.mediaDevices.enumerateDevices();\n      return allDevices.filter(device => {\n        return device.kind === \"audioinput\";\n      });\n    });\n  }\n  /**\n   * Returns the playback state of the source, \"started\" when the microphone is open\n   * and \"stopped\" when the mic is closed.\n   */\n\n\n  get state() {\n    return this._stream && this._stream.active ? \"started\" : \"stopped\";\n  }\n  /**\n   * Returns an identifier for the represented device that is\n   * persisted across sessions. It is un-guessable by other applications and\n   * unique to the origin of the calling application. It is reset when the\n   * user clears cookies (for Private Browsing, a different identifier is\n   * used that is not persisted across sessions). Returns undefined when the\n   * device is not open.\n   */\n\n\n  get deviceId() {\n    if (this._device) {\n      return this._device.deviceId;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Returns a group identifier. Two devices have the\n   * same group identifier if they belong to the same physical device.\n   * Returns null  when the device is not open.\n   */\n\n\n  get groupId() {\n    if (this._device) {\n      return this._device.groupId;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Returns a label describing this device (for example \"Built-in Microphone\").\n   * Returns undefined when the device is not open or label is not available\n   * because of permissions.\n   */\n\n\n  get label() {\n    if (this._device) {\n      return this._device.label;\n    } else {\n      return undefined;\n    }\n  }\n  /**\n   * Mute the output.\n   * @example\n   * const mic = new Tone.UserMedia();\n   * mic.open().then(() => {\n   * \t// promise resolves when input is available\n   * });\n   * // mute the output\n   * mic.mute = true;\n   */\n\n\n  get mute() {\n    return this._volume.mute;\n  }\n\n  set mute(mute) {\n    this._volume.mute = mute;\n  }\n\n  dispose() {\n    super.dispose();\n    this.close();\n\n    this._volume.dispose();\n\n    this.volume.dispose();\n    return this;\n  }\n  /**\n   * If getUserMedia is supported by the browser.\n   */\n\n\n  static get supported() {\n    return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}