{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\n\nexport class FatOscillator extends Source {\n  constructor() {\n    super(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n    this.name = \"FatOscillator\";\n    /**\n     * The array of oscillators\n     */\n\n    this._oscillators = [];\n    const options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n    this.frequency = new Signal({\n      context: this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    this.detune = new Signal({\n      context: this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    this._spread = options.spread;\n    this._type = options.type;\n    this._phase = options.phase;\n    this._partials = options.partials;\n    this._partialCount = options.partialCount; // set the count initially\n\n    this.count = options.count;\n    readOnly(this, [\"frequency\", \"detune\"]);\n  }\n\n  static getDefaults() {\n    return Object.assign(Oscillator.getDefaults(), {\n      count: 3,\n      spread: 20,\n      type: \"sawtooth\"\n    });\n  }\n  /**\n   * start the oscillator\n   */\n\n\n  _start(time) {\n    time = this.toSeconds(time);\n\n    this._forEach(osc => osc.start(time));\n  }\n  /**\n   * stop the oscillator\n   */\n\n\n  _stop(time) {\n    time = this.toSeconds(time);\n\n    this._forEach(osc => osc.stop(time));\n  }\n\n  _restart(time) {\n    this._forEach(osc => osc.restart(time));\n  }\n  /**\n   * Iterate over all of the oscillators\n   */\n\n\n  _forEach(iterator) {\n    for (let i = 0; i < this._oscillators.length; i++) {\n      iterator(this._oscillators[i], i);\n    }\n  }\n  /**\n   * The type of the oscillator\n   */\n\n\n  get type() {\n    return this._type;\n  }\n\n  set type(type) {\n    this._type = type;\n\n    this._forEach(osc => osc.type = type);\n  }\n  /**\n   * The detune spread between the oscillators. If \"count\" is\n   * set to 3 oscillators and the \"spread\" is set to 40,\n   * the three oscillators would be detuned like this: [-20, 0, 20]\n   * for a total detune spread of 40 cents.\n   * @example\n   * const fatOsc = new Tone.FatOscillator().toDestination().start();\n   * fatOsc.spread = 70;\n   */\n\n\n  get spread() {\n    return this._spread;\n  }\n\n  set spread(spread) {\n    this._spread = spread;\n\n    if (this._oscillators.length > 1) {\n      const start = -spread / 2;\n      const step = spread / (this._oscillators.length - 1);\n\n      this._forEach((osc, i) => osc.detune.value = start + step * i);\n    }\n  }\n  /**\n   * The number of detuned oscillators. Must be an integer greater than 1.\n   * @example\n   * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n   * // use 4 sawtooth oscillators\n   * fatOsc.count = 4;\n   */\n\n\n  get count() {\n    return this._oscillators.length;\n  }\n\n  set count(count) {\n    assertRange(count, 1);\n\n    if (this._oscillators.length !== count) {\n      // dispose the previous oscillators\n      this._forEach(osc => osc.dispose());\n\n      this._oscillators = [];\n\n      for (let i = 0; i < count; i++) {\n        const osc = new Oscillator({\n          context: this.context,\n          volume: -6 - count * 1.1,\n          type: this._type,\n          phase: this._phase + i / count * 360,\n          partialCount: this._partialCount,\n          onstop: i === 0 ? () => this.onstop(this) : noOp\n        });\n\n        if (this.type === \"custom\") {\n          osc.partials = this._partials;\n        }\n\n        this.frequency.connect(osc.frequency);\n        this.detune.connect(osc.detune);\n        osc.detune.overridden = false;\n        osc.connect(this.output);\n        this._oscillators[i] = osc;\n      } // set the spread\n\n\n      this.spread = this._spread;\n\n      if (this.state === \"started\") {\n        this._forEach(osc => osc.start());\n      }\n    }\n  }\n\n  get phase() {\n    return this._phase;\n  }\n\n  set phase(phase) {\n    this._phase = phase;\n\n    this._forEach((osc, i) => osc.phase = this._phase + i / this.count * 360);\n  }\n\n  get baseType() {\n    return this._oscillators[0].baseType;\n  }\n\n  set baseType(baseType) {\n    this._forEach(osc => osc.baseType = baseType);\n\n    this._type = this._oscillators[0].type;\n  }\n\n  get partials() {\n    return this._oscillators[0].partials;\n  }\n\n  set partials(partials) {\n    this._partials = partials;\n    this._partialCount = this._partials.length;\n\n    if (partials.length) {\n      this._type = \"custom\";\n\n      this._forEach(osc => osc.partials = partials);\n    }\n  }\n\n  get partialCount() {\n    return this._oscillators[0].partialCount;\n  }\n\n  set partialCount(partialCount) {\n    this._partialCount = partialCount;\n\n    this._forEach(osc => osc.partialCount = partialCount);\n\n    this._type = this._oscillators[0].type;\n  }\n\n  asArray(length = 1024) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return generateWaveform(this, length);\n    });\n  }\n  /**\n   * Clean up.\n   */\n\n\n  dispose() {\n    super.dispose();\n    this.frequency.dispose();\n    this.detune.dispose();\n\n    this._forEach(osc => osc.dispose());\n\n    return this;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}